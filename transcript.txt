welcome back in the previous video we explained how the or latrine selection method works and we mentioned the idea behind it where each chromosome covers an area of a pie chart or of a roulette wheel and that area corresponds to its Fitness value meaning that it the higher the Fitness value the larger the area is now we can simulate this by the following algorithm what we do is we loop through all members of the population all the chromosomes and we sum their Fitness value so we just compute the sum of all Fitness values for all the chromosomes we have in a population after that we generate a random number let's call it R between zero and that's that value of the sum right after that we loop through it through the population again and we compute the fitness value of each chromosome and then you just create the sum again but now at every or in every iteration we compute the value of the partial sum that we are building against that random number generated in first step from in the previous step remember R is between 0 and the total sum and here we have the partial sum because we're still looping if that partial sum is let's say greater than R then we stop there and we select the chromosome we are at right we select the chromosome we have in or at that iteration just to explain this further let's have a look at this simple java implementation right the java implementation if you look here we have an initial value for the total sum of 0 and then we loop through all the members of our population and we find the fitness value for each member for each chromosome in the population now here this can be your own fitness value function my fitness function here is named list is dashed line because as I explained in the previous videos we are solving this dashed line problem where we have several small letters small and short line segments and we are trying to find the order of those line segments so they can make a larger dashed line right please watch the previous videos or watch the videos by the end of the series just to get an idea but this again can be your own fitness function so we sum the total Fitness Fitness's of all the members of population and then we generate a random number between 0 and that Fitness and that's some and then we complete partial sum so we just loop again compute the sum at every iteration and then we compare the partial sum that we have against that random number if the partial sum is greater than or equal the random number that we generated remember arm the number is between zero and the total sum if the partial sum is larger equals that random number then we stop there and we select the chromosome or the candidate solution or the member of the population and that index X here is our index right how the idea is clear if things go wrong then we just return -1 but we should always get the index of the element we're at right so that's a simple I know the idea is quite simple you can see how short and how small the Java implementation is I'm gonna stop here in the next video which starts speaking about rank selection thanks again and see you next time 

welcome back in the previous video in fact in the previous two videos we explained the roulette wheel selection method and we saw Java implementation of it now that method will have a problem and you have probably noticed it the problem is what happens when we have members with very very high fitness values compared to other members what happens is those members will cover most of the roulette wheel and the unfortunately for the other chromosomes or for other body other members because they will cover very small areas they will have much much smaller chances of being selected but if you look at this picture here this guy for example this chromosome happens to cover most all of the area and therefore he has a much much much larger chance of being selected than for example this one this one right so if the best chromosome Fitness is 90% of all the roulette wheel then other chromosomes will struggle to be selected will have very few chances to be picked up right so random selection what happens here is we first rank the population and then every chromosome receives prettiness from it's from this ranking what we do is we complete all the thicknesses of all the chromosomes in our population and then we create an array of those frequencies and we sort the array in ascending order so the lowest Fitness will be the first I meant the second lowest will be the second element and so on and so forth and the chromosomes will have that rank so the worst will have Fitness one the second worst will have Fitness two and the best will have Fitness n which is the number of chromosomes in the population the last element of that sorted array now what if we do this then the picture changes from this or the chances changes change from this to this right because as you can see now if we use the ordering then chromosomes will have more chances of being selected but again here we would be slightly unfair to the ones with the big Fitness and that could actually cause the conversions ie finding the solution to take more time to be slower why because the best chromosomes have a similar chance of being selected to the worst chromosome I hope that makes sense right that's that's the disadvantage of this method just wanted to mention it thanks again next time we speak about the steady-state method 

welcome back the steady-state method well is not particularly a method for selecting parents but here the idea is that a big part of the chromosomes should survive to the next generation basically we want a subset of the chromosomes and hopefully the good chromosomes to survive for a next generation so the idea works as follows in every generation a few chromosomes are selected these chromosomes are hopefully good we have high Fitness values we select them for creating a new offspring right we begin with that then some chromosomes some bad chromosomes the ones with lower Fitness values are removed we remove them and then we get the new offspring placed in their place so we replace them with the ones we selected from the previous the previous step were the ones with the high and good fitness values right and then the rest of the population survive to survive to the new generation so just a way of creating a new offspring and a generation one thing one more thing that a lot I'd like to mention here we mentioned it before is the idea of elitism the concept of elitism we mentioned elitism before and we said that when we create new populations after we of course apply crossover and mutation then we have a big chance that we will lose the best chromosome or chromosomes right elitism is the name of the method where we first copy the best chromosome one or more the best chromosomes to the new population right so we want the good ones to survive and stay for the next steps for the next new population the rest is done in the classical way as we mentioned as we will explain in the next video so elitism can rapidly increase the performance of the genetic algorithm because it if we use it then we keep the good chromosome the food candid solutions so we can use them a new iteration a new iteration right prevents losing the best found solutions thank you very much for watching in the next video we will be speaking about method of youth mutation for permutation problems thanks again and see you next time 

hello again in this video on the coming ones will be speaking about crossover practice for permutations in the previous video I remember I said I was going to talk about mutation operators but now let's talk about crossover characters get them out of the way and then we'll explain mutation mutated mutation operator later now the normal cross over that we saw before the one for the binary representation does not really work here because we will have duplicates so if you look at this it leads to an admissible solution what that means is if we have two chromosomes here for permutation and if we for example chose one cut point and then swap or exchange that part with this part as you notice the new children will have duplicate values and we don't want that in permutation representations right we don't want that so there are many operators that can be used to apply crossover operators or apply crossover for permutations or repetition permutation representation these slide by the way the contents is from this very nice book into the introduction to evolutionary computing and these two authors they have provided very nice slides online you can google the name of this book and you will have access to those really nice PowerPoint slides now the first operator one we wanted to explain is called the other one crossover operator and the idea here is to preserve the relative order in which elements okay or appear what that means is we're going to randomly choose a part from the first parent by the way the input here now is to parents or to chromosomes and we work in the beginning with the first parent what we do is we randomly choose part of that parent maybe we can for example randomly choose an initial one beginning cut point or starting cut point and end a cut point and then data in the middle between those two points we can transfer it as it is to the child so we copy that part to the child after that we copy the numbers or the values that are not in the child right the ones that don't appear in the child we copy them from the second parent but as follows we start right from the cut point from the couple of the copied part and then we use the order of the second parent we just wrap around at the end and we copy elements from the second parent so again just repeat we will have an example in the next slide so we copy the values or the numbers that are not in the child from the second parent to the child we start right from the cut point of the copied part and then we use the order of the second parent and to copy and wrap around at the end and then - for example this rule of course will give us only one child if we want to have another child we just reverse the roles of the two parents I hope that makes sense right now let's have a quick look at a simple example let's say we have two input chromosomes here and you write the values ID as you can see right we randomly copy the selected set from the first parent so let's say we choose we randomly choose a start and end cut points and we end up with this and this so we copy 4 5 6 7 to the child immediately after that as we mentioned before we start after the cut point so we go to the second child and we start after the cut point and we go this way we've got 1 4 and then we go around 9 3 7 8 - 6 5 and what we do is we just go through these elements in this order and whatever is not already in the child we copy it in this order what that means we copy the rest from the second parent in this order 1 we don't copy for before is there and then we just go around 9 is not there so we copy it 3 is not there so we copy it 7 is there we don't copy it 8 is not there we copy it and 2 is not there we copy it right 6 is there 5 is there we end there as you can see we start 1:9 and then we wrap around 3/8 to help the idea makes sense in the next video we'll have a job Java implementation so the idea can become much clearer up thanks for watching and I'll see you in the next video 

welcome back into this video I'm going to be explaining my Java implementation of the order one crossover method as you can see here I have a Java method here it receives two parameters parent 1 and parent tool there are arrays I'm using arrays just for teaching and demonstration purposes of course if we use lists then they are more flexible in terms of adding and removing information so the size is much more flexible than arrays because arrays you know have limited size as you know although the good thing about them is the speed of access because you use the index directly anyway so we have two parents parent one parent too I should maybe check that the two elements are the same length just for like a sanity check but we'll skip that for the moment we compute the length of the array which is the parent parent you know third one no parent to and then we randomly choose to cut points R 1 R 2 I have a method here called random number chooses a random integer between 0 and L minus 1 likewise for R 2 here I have this loop to make sure that our 1 is indeed less than R 2 I'm sorry we don't want I want to be equal or larger than R 2 and here we'll just create a child and then we initialize its elements to minus 1 okay now what we do is we copy the elements between R 1 and R 2 these two points from parent one into the child nice and simple so far this is I'm sorry this is just the same as we explained here the two parents should to run them point and then copy the enemy's will to between those two points from parent 1 to the child ok now what we do here we create an array called y to hold the elements of parent 1 which are not in the child yet I just named it here Y right and it's size will be the total size of the parent - the size that we copied so the number of elements that we copied are here in our case would be fine this is why as you can see the size is L minus R 2 minus R 1 minus 1 right and what we do is we just copy the elements which are not in the child elements and parent 1 which are not in the child into Y here I have a simple method called array contains it received an array and one element one number for example one integer and it checks whether that number exists in the array and it returns true or false accordingly so if it's not there if the that that member of the parent a parent one is not entirely at then copied and child right after that if you remember when we mentioned that we wanted to copy now element which are not in charge one yet but in the order of the child do remember we'll eventually we can wrap around well what I do here is I just rotate the second child this number of places there the number of places or number of elements after R to right so in our case here we only have two elements after our two after this Magnolia two elements to just rotate this array we rotate it right two places so that we can have the elements in order 1 4 9 3 7 right this is exactly what I do here is just rotate it by the way I don't rotate the second parent I just create a copy of it and then rotate it number of places that the same as the number of elements after R 2 as I mentioned what we do now is we order the elements in Y according to the odor in parent or remember Y has elements from parent 1 which are not yet in the child now we order them according to the order in the second parent and if you remember we rotated copy which is a copy an exact copy of parent 2 so that we can have the remaining elements ready to to use we have them like 1 R 1 4 9 3 7 and all the way to the the rotated array so what we do is we order them according to the order in parent - this is what we do here we have another array now called y1 and in it we save the order the order elements so what we do is we loop through the elements of the copy now they rotated array and we check if any of those any element which is part of copy and exists in Y remember Y now the remaining elements from parent one which are not yet in the child if it's there then copied to Y one right if it's the copy to Y one and now why one has the element elements which are not yet in the child but in their order and the order according to their order in parent - I hope it makes sense I keep repeating myself just to make sure the idea is clear right so Y 1 now has the elements in the order that we want and all we need to do is copy them into the child now if you notice the child here has empty elements well how do we know where to start with what one thing that we can use if we want we can rotate right copy the elements nicety and then rotate left the same the same number of places or what I use here is I use just the modulus so here I just work out the right index for each element I loop through the elements of y1 and then work out the air the index r2 because we want to start after r2 as you notice right so r2 + I which is the current index of y1 + 1 modulus module el right the modulus here will give us as you know for example this array has nine elements so 0 1 2 3 4 5 6 7 8 8 modular 9 is 8 if we go further 9 1 0 9 is 0 so we go back to the first element right does that make sense I hope it makes sense this this is how we can copy those elements to their right places as I mentioned you can do the rotation or you can use the modulus I just wanted to show you another way of doing it now the child has the new child of course is completely filled with the information already do all we just all we need to do is to return it right if we want to create another child from two parents then we just swap the order right as parent one becomes parent - I'm currently becomes parent one and that way we can have another child so this code will be using it when we put everything together by the end of this course so that everything makes sense right thank you very much for watching and I'll see you in my next video 

welcome back we're still covering crossover methods for permutation representations in this method in this video we're going to be looking at the partially mapped crossover in this method we build an offspring by choosing a subsequence of elements from one parent and basically we try to preserve the order and position of as many elements as possible from the second parent the subsequence of elements or that chunk that we copy from the first parent to the child is selected by choosing two random cut points by using that we use those two cut points as boundaries for the swapping operation so we've seen that before now the partially map crossover algorithm works as follows please pay attention it can be confusing on the next slide we have an example which will hopefully make things clearer pay attention if you don't get a first time then there is no harm of watching it again so we have two parents p1 and p2 we randomly choose a segment and copy from p1 to the child and then we start at the first cross over point we look for elements in that segment of p2 so in the corresponding segment of p2 we find the elements which have not been copied yet for each of these elements we'll call them I elements we look in the offspring we look in the child to see what element J has been copied in its place from p1 notice now we're dealing with elements and their places so for each element I these are the elements in the segment in p2 in the segment that we copied but now in p2 what's about being copied yet we look in the offspring and see which elements have been copied in its places from p1 we call those elements J elements what we do now is we place I into the position occupied by J in p2 since we know that we will not be putting J there as already in the spring right J is already in the offspring as J is already in the offspring right so let's put that red yes so they're in your spring now if the place occupied by J in p2 has already been filled in the offspring by an element k then what we do we put I in the position occupied by K in p2 right hope that makes sense as I mentioned the idea would be much clearer when we use an example having dealt with with elements from the crossover segment the rest of the offspring can be filled from the second parent directly into their corresponding positions so the problematic part is the elements in the random segment that we choose the elements in p2 which have not yet been copied to p1 let's have a look an example as an example so we have two parents parent one parent - let's say we randomly choose that segment we copied directly to the child so that's the first cut point this is the starting cut point as the ending cut point we copied them directly from the first child and then we look at the corresponding segment now in the second parent we find the elements which have not been copied yet so eight has it been copied no two hasn't been copied six is there and five is there so my eye elements if you remember from this step two and three the eye elements now are eight and two right so what we do now is we try to find the corresponding elements now in the offspring in the child or maybe even in the first parent I I'm sorry there's a mapping between eight and four and a mapping between two and five so my J elements now are four and five so I is eight it maps to 4 and I here is to imagine five right these are the are elements and these are DJ elements so what we do as we mentioned before is place I in the position occupied by J in p2 so let's have a look at Jay here for 8 i is 8 j is for in p2 so look at j4 in p2 for is there we directly put 8 in place for 4 and as you can see it goes there directly right because the place was not occupied however there is a small problem what if that place is occupied so as you mentioned here that place is empty right which is the place of 4 in P to the place of J and P 2 is empty we copy I directly 8 we put it there but if you look at 2 2 maps to 5 so let's have a look at where is 5 in p2 v is there and if we look at the child well there is an element 7 so how do we how do we deal with that that is K here okay that is K here what we do is we find K okay and we find the position of KMP to now and we put the I there in that position but now in the child so k 7 let's find K in P - K is there we put I in place of K right in the position of K in the second parent so 2 goes there hope that makes sense the rest of it is copied directly as you can see - here goes in place of 7 the place of 7 in the second pair but not in the first round the rest of the elements are copied directly from the second parent so we end up with 9 3 to 4 5 6 7 1 8 hope makes sense thank you very much for watching and I'll see you in my next video 

welcome back another crossover method for the imitation representation is the cyclocross over the basic idea here is that each element comes from one parent together with its position and it's one it's method is actually quite funny the procedure is as follows we have two parents parent 1 and parent 2 o P 1 or P 2 what we do we make a cycle of elements P 1 as follows we start at the first element of the first parent we look at the element at the same position in the second parent now what we do we look at the element at that position in the second parent and we go to the position occupied by the same element but now in parent 1 and then we added to the cycle and then we repeat right we look at the element in that position impairing 2 and then we find the position with the same element in parent 1 and we repeat repeat repeat until we arrive at the first element of P 1 the one we started off with we put the elements of the cycle and the first child in the positions that they have in the first parent and then we continually move 1 we choose the next element in parent 1 which is not in the cycle and then we do the same thing we start there we look at the same that we look at the element in P 2 at the same position and then the value of element in P 2 that value now we try to find its position in P 1 and we continue the cycle and then we take the next cycle from the second parent let's have a look at an example to make things clear let's say we have two parents as you can see a front view this one and this one we start off at the first element of parent 1 here the value is 1 right now we find the corresponding element not the value we'll find the element number 1 in parent to now in parent too we check the value which is now we find the value 9 now parent one which is there before the ro9 is there now we are at nine we'll find the element muck with that value but at that position in parent two which is four now from parent to we check the element value you will find that value in parent one for now from parent one we don't find element foreign parent to work rather we'll find the element at the same position in parent 2 which is 8 and then we find 8 now in parent 2 and then we find an empty element at the same position in parent and sorry we are we're we're at parent 1 now we find the element at the same position in parent 2 which is 1 and now we find we check the value of that element see we rejected we always check the value at the second parent we find that value it will find its position in parent 1 which is 1 now we we went back to 1 this is where we started so now we have a cycle notice now the numbers the areas great right there is great right is a shadowed now we move on to the next element which is not in cycling it is element number 2 we found the corresponding element ie element in the same position in the second parent which is 3 but now we look at the value will find that value in the first element which is there and then from there we look at the element in the same position at the set in the second part which is 7 and then 7 we now look at the value we remember we said we always look at the value in the second parent will find that value in the first parent it's there and then from that we find the value at the same position in parent 2 which is 5 and then from 5 we look at the value we find 5 in parent 1 right and then from 5 we find that we found the value in parent two at the same position which is 2 now and now a 2 as you mentioned before always look at the value in the second parent we look at two we've tried to find it in parent 1 well 2 is there so we go back to the cycle right we close the cycle note so yeah to you go to 3 from 3 we'll go to three in the first parent and then corresponding element is number seven value seven is there we look at the corresponding element is five value five is there in the first parent and then the corresponding by element is two and then we find value two in the first parent wishes there and now we are back to the beginning of the cycle so that's the second cycle and then the only left element now is six there's no cycle so six will stay as it is and then we just copy now alternate cycles into the offspring notice that we can actually have two children rather than one so we copy the first cycle from the first element to this child and then the second cycle the second elements of the cycle from the second child I'm sorry from the second parent and then for the second child what we do is we copy the first cycle or the first element the elements in the first cycle from the second parent and the elements of the next the second cycle from the first parent and then we get another child as you can see it's quite fun I hope it makes sense have a look at the steps here and then at the example for things to be clear thank you again for watching and the next video on all words we will be looking at mutation methods for permutation representation text thanks again and I'll see you next time 

welcome back now we have learned three different methods to perform cross over for permutation representations and we actually had a look at a Java implementation of one of them that was the order 1 crossover method in this video and the next few ones we will learn several mutation methods and we will also see a simple java implementation for each of them the first one is the insert mutation remember we're doing now permutation representation and the idea for mutation as we mentioned before is that we only have one input so one parent we change the elements inside that parent we basically change their order and then use them in our population so for insert mutation the idea is we have one input one parent we pick two elements at random and we move the second element to follow the first so to be right next to the first element and we shift the rest of the elements along so we can accommodate the second element when we bring it to become next to the first element notice that this method preserves most of the order and the adjacency information so much not much order is changed here so if we look at an example let's assume that our input chromosome looks like this an array of integers from 1 2 3 all the way all the way up to 9 and the two random numbers we choose or the two random elements are maybe index 1 and index 4 notice that we start with index 0 so index 0 index 1 2 3 4 5 6 7 8 assuming that the run the first random index is 1 the second random index is 4 what we do is we shift that 5 to become next to the tool so after 2 and then we just push these elements to the right as you can see here so bring the files to be next to the tool and then push these elements to the right so we can accommodate the file to come here the Java implementation looks like this we have a method here called and segmentation we receive only one parent array of integers remember that we use arrays here just for demonstration and teaching purposes usually we would use lists because they are more flexible so what I'm doing here is I'd like to make a copy of the array and then work on that copy and then return the changed one so I'll just preserve the input we can of course as you know until you know how Java works we can work immediately on this array and then we don't have to return right this can be void and the change will automatically happen on the input array in a way so we make copy of that array we get its length how many elements it has and then we get two random integers between zero and the size of the array so two in two random indices r1 and r2 I have a method here called random number it generates a random integer between zero and L minus one so L here is not inclusive right from 0 to n minus 1 R 1 R 2 and then here I have a while loop just to make sure that our 1 is less than R 2 with a 1 I want to be equal to or larger than R 2 because as we mentioned here this is R 1 this will R 2 we want to bring the element at r2 to come here be next to the element at R 1 so we do that make sure that R 1 is less than R 2 and then what we do is we start at we look through the elements we start at the element at R 2 minus 1 yeah and we make sure that our index is larger than R 1 because we don't want to touch our 1 and then we just go backwards that's why we decreased the will decrease I here so what we do is we start here at our my I to minus 1 and then we go left that's why we decreased so what we do is we start here we swap these two elements so the four comes here five comes here that's been one iteration and the next iteration now we have three and five five comes here and three goes there and that's it that's what this code does we just get the element at I plus one and a temporary variable and then we just swap it with the element before it right remember that I and I plus 1 I we start in the first iteration our I is equal to R minus bumps or r2 minus r2 minus 1 which means that I plus 1 is actually the element at r2 so that's the beginning we swap are to animate at r2 with the element r2 at r2 minus 1 in the next iteration we swap the element at r2 minus 1 with the element at r2 minus 2 and so on and so forth and that way we can shift this element one by one to come here we stopped at one because as I mentioned the on here is a larger than r1 right now the idea makes sense in the next couple of videos we'll have a look at more annotation methods thanks again and we'll see you next time 

hello again the second mutation method we wanted to learn in this series is called the swap application as the name suggests is extremely easy what we do is we have our input chromosome we just randomly pick two elements and then we swap their positions it's as simple as that this method as you noticed it preserves most of the adjacency information so not major changes happen in the chromosome if we look at an example let's let's say we have the our input looks like this just a simple integer array then we randomly choose to point let's say 2 & 5 what we do is we just swap them so 5 comes here and 2 goes there the Java implementation is extremely easy again here we have a method called swap mutation receives array of ends and returns an array in so we just make a clone of the I'll copy the a copy of the array there's no need for that we can do the mutation in immediately only input array but you know just a way of preserving input calculate the length of the input and then we randomly pick two numbers r1 r2 just to repeat I have a method called random number which generates a random integer between 0 and L minus 1 so L is not inclusive r1 r2 and we don't want our one on output to be equal so we just keep looping which is r2 until it's not equal to r1 just in case because we don't want to swap an end with itself doing after that we just do the swap process the one that we always do in programming just hold the first drive with a temporary a temporary variable copy the second variable to the first variable into the first variable and then we copy the temporary into the second and we return the array nice and simple as we mentioned not much changes so most of the adjacency is kept but it can work obviously as the actual input chromosome changes even though it's very very it's a very very small change taxing of Washington and I'll see you in the next video 

welcome back the third mutation method for permutations is known as the inversion mutation in this method we randomly pick two elements and then we invert or reverse the substring or the values between them right we just randomly pick two points and then we reverse that sub array or sub list we just reverse it reverse it or invert it this method preserves most adjacency information but it's disruptive of the order information okay the way things are ordered here get disrupted let's have a look at a simple example we have the same array that we used before let's say that we randomly choose two points and the start the start cut point is here and the end point is here what we do is we just reverse that that sub array so it was 2 or 3 5 4 it becomes 5 4 3 2 basically what we do is we swap the first element with the last element we swap the second element with the element before the last or the or the last from from the end I'm sorry the second from the end and so on and so forth right we just invert that array one thing I'd like to say when we explained the swap petition or insert mutation it does not necessarily mean that if you look at the code it does not certainly mean that we can only do this once no rather we can do it several times so you can have a loop to do this several times right like here for the insert invitation or for the swap mutation we can do this several times it will give us new chromosome right now for the inviting attention as you mentioned this is how it works and the way we do it here here I actually do it five times so the same idea from before input to the method is integer array we make a clone of it we calculate the length and then we're going to repeat this idea of randomly choosing two points and then reversing the array the sub array between them we're gonna repeat it five times so run two points the way we did before we make sure that our one is less than R 2 R 1 and R 2 now our two indices in the array right in this in this array what we do is we find the middle point between R 2 R 1 and R 2 because what we do we use the middle point to swap elements from the far right of the pool and the far left and so on and so forth and then we just loop through the elements int I equals R 1 we start at r1 and we go all the way to the middle point and then we swap the first element the element at I with the last element which is r2 right we swap those and then in the next iteration we notice that end count as artists we decrement that by 1 so now in this in the second iteration we are at the element 2nd from from from the last the element just before our the element at r2 and then we swap it with the element right after 1 and so on and so forth I hope the DMX urns which I defy the funny middle point obviously here we don't have middle point because the length of the sub-array is 4 so if it was 5 let's say if we had 2 3 4 5 6 then the middle point is at fault then what we do is we swap two with 6 and then in the next iteration we swap 3 with 4 right but in the end the idea here we're going to swap 3 with 4 and then 2 with 5 so we have 5 3 5 4 3 2 a second look at the code and notice that we actually repeated 5 times very important to understand the idea of finding the middle Point and then swapping the elements from the right and the left at that point thanks again for watching in the next video we'll have a look at our final mutation method after that we'll speak more about the problem that we're going to solve using Tim two algorithms thanks again as you next time 

hello again the final imitation method we're going to look at is called scramble imitation the idea again is to have one input chromosome and to pick two elements at random and now what we do is we randomly rearrange the substring or the subset or the sub array between them the idea is to scramble and randomize the sub array between them by the way the subsets that we choose don't know it doesn't have to be contiguous so we can say for example let's say 2 or 3 & 7 right elements there and then we just try element there element that an element there and we'll just randomize them and then just change their order in the random way right I'm not here to make things to make things simple we're going to assume that we are choosing a contiguous subset so let's say that randomly which was two numbers how one is there are two is there that's our sub array then we just randomize the elements and then the resulting chromosome now looks like this right after applying scramble mutation Java code is quite simple what we do is receive an integer array as we mentioned before then we just make a clone of it to keep the parent unchanged although we don't have to do that and now I try to repeat the process five times write the randomization process I tried to repeated five times we choose two random numbers r1 r2 between zero and the size of the array notice that my method here called random number it generates a random integer between 0 and L minus 1 so L is not included is L is exclusive and this while loop is just repeating myself is to make sure that our 1 is less than R 2 so we keep if R 1 is larger than or equal to we keep looping and changing to random number between 0 and the size of the array until we managed to do that so again 0 random number here will be between 0 and L minus 1 and then here I just loop 10 times right and now what I do is I choose two random numbers between r1 and r2 now right 200 between r1 and r2 now and our 1 and r2 are inclusive this is why I say r2 plus 1 choose them and then swap the elements add those indices right I just do this 10 times repeat these 10 times to make sure that something happens and we randomized the elements what that means is let's say I want out r2 r2 there and then we choose two numbers now between r1 and r2 let's say which was 3 & 5 yeah nuts up index is 0 1 2 3 4 so random issues 2 & 4 we just swap them and then iterate again and we may be randomly choose element there and swap there and we keep repeating until you know as many times as we want really and then we stop and return the new array or the new chromosome right so I'm going to stop here in the next video I am going to present you the problem that we're going we're going to solve via genetic algorithms of course permit for permutation representation and hopefully things will make much more sense when you see it in action thanks again and I'll see you next time 

welcome back now we start describing the problem that we're trying to solve this is a toy problem so it's quite simple remember this is only for demonstration purposes for teaching and for education purposes and the idea here is to just explain and illustrate how we can use generative algorithms to solve permutation problems so our idea here our problem says that we have the coordinates of ten short line segments or ten dashes and these ten dashes form one big dashed line as you can see in front of you the idea is that we have their coordinates but we don't have the correct order and order for them to form the dashed line the best line as you can see we want to know the first point the first second and third dashes on and so forth all the way up to the tenth - so we can find the starting point and the ending point of the dashed line so we would like to find the right order to form the dashed line right to represent the solution we will just use a simple array of integers and it's going to be of size ten because we have ten dashes and we will use numbers from 0 all the way up to nine as you can see though each of these members in this chromosome or in this candidate solution will be 1 - and the idea as we explained before when we did the binary representation or the genetic algorithms for binary representation we will create an array of size 10 - OH - hold the coordinates of the ten dashes we will call that array dashes so it'll have the coordinates x1 y1 x2 y2 of each - and we will use these numbers this will be the index of the - in the data arrays so when we say - that means the - at index number 2 so 0 1 2 and so on and so forth right and we will create our population the chromosome matrix or population let's assume we we start with 30 elements for 30 by 10 the 30 represents the population size of 30 could be any size really as we mentioned before to be big enough to allow some solutions to form each member of this matrix represents a possible solution this is not a binary array of size 10 now rather in an integer array of size 10 and a simple example solution will look like this we will use these numbers as we mentioned or the members here of each chromosome to access the coordinates in the data array as we mentioned for example this element here it says 3 that means element at index 3 of the dashes eraser 0 1 2 3 in Java it will look like this to create jeans matrix or the population or the you know chromosome matrix 30 members 10 line segments each now in the next iterate video we will explain how we can evolve the population ie how we can change it and then after that we'll have a look at the full code remember you will find the link to the code below this video thank you very much fool in fact you know not only this video but all the videos thank you for watching and I'll see you in my next video 

welcome back in this video we will learn how we can evolve our population to have a new population if you remember genetic algorithms are iterative so in each iteration we have a population we'll try to find the best solution in that population if you don't find them then we evolve that solution in the next iteration ie I'm sorry not involved a solution but evolve the population ie maybe we have a new population in the next iteration and so on and so forth so the idea is at each iteration at each iteration we will try to have a new population of candidate solutions and we'll try to keep hold of good candidate solutions from the previous iteration ie we will try to have some degree of elitism as we explained before so how we're going to do this is as follows we will loop through the previous or maybe the current population we will choose two chromosomes we explain the roulette wheel selection method to reduce that which was two chromosomes to candidate solutions we'll try to apply crossover randomly if no crossover happens then we will choose the best of them to add it to D to add it to the new population so this is the degree of elitism that we will have a fight between the two chromosomes that we randomly chose and having a fight basically will we will compare the fitness and then the best one is the one with the high effect with the higher fitness in our case and then we will try to apply crossover of no crossover happens then we'll keep the good one and after that after we fill the population our size remembers 30 so after we have 30 new chromosomes then we will again look through the population and to try to apply random mutation randomly means it can happen or it cannot happen as we will see and this is the code as you can see in front of you let me resize this so we can this green here the idea here is to do the following we assume of course that our population has been initialized it's declared globally so we can access it here there's no input parameter and the method doesn't return anything so we create a new population of population size which is 30 and 10 line segments each of the chromosome length is 10 now we just keep track of the basically the index of as we mentioned we want to choose a winner from two chromosomes what we do is we loop through the population this is the previous population now and we randomly select two elements using the roulette wheel selection method will explain the implementation of this before we make sure that two elements are different there must be different this is why do we have this two while loop here and then what we do is we'll have a fight see which one of them has the best genes ie we'll just compare the fitness of the two chromosomes that we chose a and B right so eval solution is our Fitness method it will evaluate the solution at index a and at index B and we will see if the fitness value of a is larger than B then the winner will be a the loser will be B otherwise the winner will be B and the loser will be a right so this is our winner chromosome the best of the two that we have chosen then what we do is we just keep track of it we just save it into this temporary variable because what we want to do now is we just randomly apply cross over so we have a variable code called crossover rate between 0 and 1 and then we just generate a random number between 0 and 1 and see if that number is less than crossover right then we apply crossover this is just a way of applying randomness right and then what we do is we save that element okay into the new population and then we loop again until we do the 30 elements after that we look again through the elements now of the new population and again randomly try to apply mutation we have a variable called mutation rate and if it's if we generate a random number between 0 and 1 if it's less than that iteration rate then we apply it of course you can say for example larger than instead of less than it's up till the way you want to do it and then we just here we apply scrambled mutation but we saw before that we explained four methods we have swap mutation and so on and so forth right and then we'll just be now all population we just replace it with the new population hope it makes sense this is how we can evolve the population at every iteration of our algorithm by the way I have not explained the fitness function yet I'll do that in the next video thank you again for watching and I'll see you next time 

welcome back in this video we are going to explain our fitness function remember always when you use genetic algorithms to solve a certain problem two extremely important points are number one the representation of the solution number two the fitness function Fitness function can be different for each different problem in our case here's what we're going to do exactly the same as we did before for the binary binary operation problem that we had a look at in the previous videos so for each candidate solution we will check the array elements for collinearity the the idea is as follows we check the first element against the second the second against the third the third against the fourth all all the way up until the ninth against the tenth that means we will have nine pair wise comparisons because as I mentioned our solutions consist of ten elements now we will count the number of adjacent and collinear pairs that means if for example when we compare the first against the second if the fourth if they are collinear and adjacent then that would count as one of the second against the third both of them of the two elements are adjacent I think that counts as two and so on and so forth which means because we don't mind pairwise comparisons if all is true we will end up with number nine so if the number is nine then indeed the elements do form a dashed line and we have found the solution however if this number is not line then the elements do not form a - solution a dashed line but we will keep track of the best solution so far so let's have a look at this figure here we have the dashes we compared the collinearity I'm sorry we will compare adjacency how close they are using a variable called dash the dash separation as we explained in the previous videos and then we check the colinearity using this idea of the radius of collinearity one thing I'd like to mention here is this idea of keeping track of the best solution so far in our case here we know the solution which is you know the comparisons return nine but in real life we don't know the solution if we are not solution then what's the point of you know doing this anyway for example for the Traveling Salesman problem we don't know the solution but we want to keep track of the best solution so far in that problem the TSP problem we're looking for the shortest distance or the lowest costs right so fitness function will be looking at you know as you know as low as possible 1/4 of the value of the output value whereas in our case the want as high as possible and our highest is nine remember here we know the solution already which is to have the number nine but in many cases we don't know the solution this is why we keep track of the resolution so far right let's have a look some let's have a look at some code now this is my fitness function I named it here eval solution it returns an integer the number of comparison number successful comparisons we send at the chromosome the array from the population as we explained before I keep reminding myself I knew that the fitness function will change for every problem domain now we need to record how good this population member is I transform it into a - again just for demonstration purposes we can use the array immediately no problem with that and then what we do is we just compare each element with the element after it so I compared compared to I plus 1 so 0 compare the element at index 0 compared with element at index 1 and then compare element at index 1 against element and index 0 and so on and so forth we have these two methods in our utility class check checks whether the two dashes are collinear other method check whether the two dashes are adjacent we explained this before by the way the link to the code will be below this video so you can find it and have a look this is the utility class for example adjacent dashes they you know receives two parameters of type - and then it makes it this one checks whether they are decent or not comparing the distance between them against the - separation distance and the other one which is the Kalina - is it just checks basically it draws an imaginary line between the farthest to endpoint of the - of the two dashes and then checks the other two points how far they are from that line which ya against the radius of community this RLC variable anyway we count a number of successful comparisons number of collinear adjacency lists and we return it so if that number is 9 that means we've found a solution if not then we keep track of the Vestals and so far I'll show you how we do that how we keep track of the best solution so far and the next few videos so I'm going to stop here and then we'll have a look at more of the implementation and we'll execute it as so you can see how actually works thanks again for watching and I'll see you in my next video 

welcome back finally we will start showing the complete implementation of our genetic algorithm to solve this permutation representation problem in this implementation I will have the following five classes a class called point which is a simple class to model a point we've seen this before when we did the binary representation problem to a quick look here a cluster to present the bit were present the point it has two coordinates x and y right another class is called - or maybe you can call it line segment a simple class to model a line segment as you know we will only have the two end points of the Alliance segment so this class called point will be used here in this class - or maybe as I said we can call it for example line segment right it has two coordinates - points yeah at least I just still get the values another class this is actually a bit class I named it utility in it I have put several methods such as methods for checking the adjacency of two line segments or checking the collinearity of two line segments as I explained in the previous videos maybe the methods - for generating random numbers the method for randomizing array contents for example when we initialize the population and much and many many more methods I I'd like to check it all the methods are committed so they should be self explanatory there's many of them for example finding the distance between two points finding the maximum and the minimum number in an array of you know in a double array using dot product and cross product here to find the distance for example between a point and a line segment i'm sure i'm sure you're familiar with this panels i said many many more methods so have a look at them checking adjacency checking colinearity generating random numbers as we mentioned before finding the index of an array in an element for example sorry the index of an element in an array you know what rotation we spoke about these things when we implemented all the 1-crore saw before and much more as we mentioned before shuffling the array here just to randomize our elements oh and we use this when we do when we initialize the population right and then I have placed the for mutation methods that we learn in the Chris we did we learned in the previous videos applies them in a class called mutation just to make things easy to understand class called mutation swap mutation and set mutation embracing mutation and the scramble mutation we've seen these before right and then the permutation genetic algorithm this is the actual class where we implement the where we run the general algorithm right now in this class this is what we're going to do we will start with a random population and then we'll repeat the following steps maximum number 12 times all until we find the solution so we have two ways to stop the program either we find the solution or we reach the maximum number of iterations right what we do is we start as we mentioned with a random population and then we'll find the fittest element in the population if it's Fitness is 9 then we found a solution if not then we keep track of it because as we said we want to keep track of the best solution so far we evolve the population and then repeat now we have because we have a new population we explained this before and we have seen the Java implementation so we just repeat go find the fittest element in the new population if it Fitness is 9 then you find the solution otherwise keep track of it and so on and so forth so this class looks as follows we just declare several variables the population size the length of the chromosome 10 because we have 10 dashes mutation rate crossover rate to randomness to the process we say maximum number of toes maybe 3,000 remember the number of elements here is 10 if the number of elements is 30 for example the problem will be almost impossible to solve because the number of permutations is extremely large I mean I can't even tell I pronounced that number yeah it's extremely loud right and here we have 10 dashes we have coordinates so the right order is - one - two - three - four - five - six - seven - eight - nine - ten right we put them in this array of dashes as we explained before and then we just in create and pop it the population and then we'll initialize it later the size is population size thirty members each member is of length 10 and then you know this is like in a initial chromosome so this is the perfect solution but will randomize it and then we try to find the solution via the general algorithm and then we want to keep track of the best chromosome so far so we say okay let's assume that our breasts chromosome so far initially is a fitness zero you know decide is no two consecutive elements which are collinear an adjacent right and then we just keep track without from the solution or not in the main method recall we call this method called run G a let's stop here and explain more in the next video thanks again I'll see you next time 

welcome back so this is the method to initialize the population we will use it in this method called the run g8 and the idea here is to loop through the population that we created here and then each element we just run demise the the elements of this initial chromosome right this shuffle into a right method we've seen it here in the utility class this is we use it this is what we use to randomize the elements of this array right I should say here I should you know add the parameter it receives and what it returns I'll do that later right but this is the method that does the shuffling or the randomization so this is how we start the initial population this method is used to find the prettiest member of the population fittest member is the one with the highest population so far right and then evolved population we've seen this method before in the previous videos so I'm going to skip explaining it here again and the selection using that wheel we've seen this before again so let's skip it and go to the Run GA this is where we start in the beginning we initialize the population randomly by calling this method called init population we've seen that and then we loop number of the number of times the maximum number of tours as we said with the clarity as to be 3000 what we do here I'll just print out the current tournament number to keep track of how many tournaments and then I just try to find the fittest member of the current population right as we have explained previously and I check the fitness now of this population member if it's nine and then we found a solution we just display the results using the display method and we found a solution true so we can exit otherwise we keep track of the best solution so far so we say if the fitness of the fittest member of this population is larger than the fittest fitness of the best chromosome so far the one we declared earlier will fitness of zero initially if you remember then make the best chromosome so far is our population but making I'm sorry make the best chromosome so far let it be all give it the value of the fittest member of the population so far and then we evolved the population and we keep repeating we saw this evolved population method before where is it yeah yes we've seen it before in the previous video right so if we found a solution then that's fine we just display if not at least we have the best chromosome so far and this is the display method which gives us just displays the results basically so after how many tournaments bashing from our one line our and then we just print out the coordinates of the of the dashes and here this is the as a list method we said we used before to transform the array into a list we explained this in the previous when we spoke about finding the Fitness this is the fitness function or Fitness method eval solution you know how we do in mind comparisons because we have ten elements as we explained before I'm not going to repeat this this is the all the one crossover method that we again saw before and this is just a method simple method to print out the population so enough talking let's have a look at how this program works remember a link to the code you will find it below this video let's run it as you can see here is printing out tournament number we've not found the solution yet we set it to be 3000 so it will take some time to to finish where is evolve population method I'd like to show you which crossover method observe which mutation method we are using so we're using all the one crossover that's what we implemented but in the mutation we do run run the message as we mentioned before we use currently scramble mutation so it has actually reached two okay three thousand times what it hasn't found the solution we can run it again or maybe we should print out the best solution so far sorry I paused the video what I did here is I went back to the main method and I added the simple check to check whether the solution was found or not if not then we can at least print out the fitness of the best solution so far and that's by doing eval solution for the best chromosome so far remember in the Ranji a method we keep track of the best solution so far right the best chromosome so far is the same as the best solution so far so if we know if we found the solution then the misted method display will will be will display the results otherwise we do all the tournament numbers then maximum number of tournaments and then we print out the fitness of the best solution so far right so this would maybe what you want to do when you try to do the Traveling Salesman problem you want the best or the lowest or the shortest distance so far where is my main method there you go so let's run this again quickly and it will give us if we find the solution that's fine if not then we should get at least the fitness of the best solution so far right three thousand times this is the maximum number of tournaments is concert eight let's wait a few seconds maybe I should pause the video again here it's still trying solution found yet so if you repeat this several times it will find the solution but as you can see here the best the fitness of the best solution so far is 8 so you can print out maybe the contents of that solution or maybe let's say you want to change the mutation method so we did scramble mutation let's do for example swap mutation and see what happens you pause the video right I paused the video and it didn't find a solution yet so let's for example do instead of swap insert mutation maybe maybe you should have implemented another crossover method but let's try again see you again let me pause the video again alright I pause the video you can see it still trying a no solution is found the best solution the fitness with the best solution so far is is 8 as you can see if repeat if you repeat this several times it will found the solution with Fitness 8 which is the perfect solution otherwise at least we keep track of the best solution so far so I'm going to stop here this is the end of the series I hope you've enjoyed it remember the link to the through the slides and to the source code will be below these videos thank you very much for watching and I hope to see you in another tutorial 

